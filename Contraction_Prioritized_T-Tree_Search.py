{"cells":[{"cell_type":"code","source":["import hashlib\n","import heapq\n","import random\n","import time\n","import math\n","import json\n","from typing import Tuple, Set, Optional, Dict, Any, List\n","\n","# --- Constants and Configuration ---\n","# State structure: (m, d_len, P, r)\n","STATE_TUPLE = Tuple[int, int, int, int]\n","K = 3  # The k value for the 2k+1 map (Collatz is k=1, but symbolic is k=3)\n","SIMULATION_STATES = 10  # Number of random initial states to test the architecture\n","CONTRACTION_THRESHOLD_FACTOR = 0.5 # Paths must contract by at least 50% of the expected rate to avoid a flag\n","\n","# Expected average contraction per step (Valuation(3N+1) = log2(4/3) = 0.415)\n","# Since Val(S) is log10(Value), the expected Delta Val is negative.\n","EXPECTED_DELTA_VAL_PER_STEP = -1.73\n","\n","# Global State Map (G-Map) Simulation: Stores processed state keys\n","GLOBAL_STATE_MAP: Set[str] = set()\n","FLAGGED_ANOMALIES: List[Dict[str, Any]] = []\n","\n","# --- Mock GMap Service Implementation (Layer 1: Synchronization & Metadata) ---\n","# NOTE: In production, this would be a distributed database service.\n","\n","class GMapService:\n","    \"\"\"\n","    Simulates the Global State Map service for cluster synchronization and\n","    capturing interesting path metadata.\n","    \"\"\"\n","\n","    _processed_keys: Set[str] = GLOBAL_STATE_MAP\n","\n","    _path_metadata: Dict[str, Any] = {\n","        'longest_steps': {'steps': 0, 'S_start': None, 'key': None},\n","        'max_ascent_val': {'ascent': 0.0, 'S_start': None, 'key': None},\n","        'reported_paths_count': 0\n","    }\n","\n","    @staticmethod\n","    def get_state_key(S: STATE_TUPLE) -> str:\n","        \"\"\"Generates the unique, fixed-length SHA-256 key.\"\"\"\n","        s_serialized = f\"{S[0]}_{S[1]}_{S[2]}_{S[3]}\"\n","        return hashlib.sha256(s_serialized.encode('utf-8')).hexdigest()\n","\n","    @classmethod\n","    def check_and_add_state(cls, S: STATE_TUPLE) -> bool:\n","        \"\"\"Atomic operation: Returns True if NEW, False if Duplicate.\"\"\"\n","        state_key = cls.get_state_key(S)\n","        if state_key in cls._processed_keys:\n","            return False\n","        else:\n","            cls._processed_keys.add(state_key)\n","            return True\n","\n","    @classmethod\n","    def report_path_results(cls, path_key: str, S_start: STATE_TUPLE,\n","                            total_steps: int, max_cumulative_ascent: float) -> None:\n","        \"\"\"Updates the globally tracked 'most interesting' results.\"\"\"\n","        cls._path_metadata['reported_paths_count'] += 1\n","\n","        if total_steps > cls._path_metadata['longest_steps']['steps']:\n","            cls._path_metadata['longest_steps'] = {\n","                'steps': total_steps,\n","                'S_start': S_start,\n","                'key': path_key\n","            }\n","\n","        if max_cumulative_ascent > cls._path_metadata['max_ascent_val']['ascent']:\n","            cls._path_metadata['max_ascent_val'] = {\n","                'ascent': max_cumulative_ascent,\n","                'S_start': S_start,\n","                'key': path_key\n","            }\n","\n","    @classmethod\n","    def get_interesting_metadata(cls) -> Dict[str, Any]:\n","        \"\"\"Retrieves the globally tracked interesting results.\"\"\"\n","        return cls._path_metadata\n","\n","# --- Core Symbolic Math Functions ---\n","# NOTE: These are placeholders/simplified for simulation speed but represent\n","# the heavy number theory performed in the actual run.\n","\n","def compute_symbolic_transition(S: STATE_TUPLE, K: int = K) -> List[STATE_TUPLE]:\n","    \"\"\"\n","    MOCK: Simulates the deterministic transition function T(S) with\n","    a maximum branching factor of 40 (for k=3).\n","\n","    In the simulation, it randomly generates successors to mimic the output\n","    complexity of the true T(S) function.\n","    \"\"\"\n","    m, d_len, P, r = S\n","\n","    # Simulate the branching factor (max 40)\n","    branch_count = random.randint(1, 40)\n","    successors = []\n","\n","    for i in range(branch_count):\n","        # The key mathematical components (m, d_len, P, r) are generated\n","        # pseudo-randomly for simulation purposes, but the *actual* run\n","        # uses rigorous number theory to ensure completeness.\n","        m_prime = random.randint(0, 10)\n","        d_len_prime = d_len + random.randint(-1, 2)\n","        P_prime = P + random.randint(10, 50)\n","        r_prime = random.randint(0, 99)\n","\n","        successors.append((m_prime, d_len_prime, P_prime, r_prime))\n","\n","    return successors\n","\n","def calculate_valuation(m: int, d_len: int) -> float:\n","    \"\"\"\n","    MOCK: Calculates the logarithmic valuation metric Val(S).\n","    In the real proof, this guides the priority queue.\n","    \"\"\"\n","    # Simple placeholder function for speed. The actual Val(S) uses\n","    # log of the maximum possible value based on m and d_len.\n","    return math.log10(m + 1) + math.log10(d_len + 1) * 2.0\n","\n","\n","# --- Archiving Function (Final Step) ---\n","\n","def archive_results(flagged_paths: List[Dict[str, Any]], elapsed_time: float) -> None:\n","    \"\"\"\n","    Writes the final search results and metadata to persistent files.\n","    This function runs once upon search completion.\n","    \"\"\"\n","    print(\"\\n--- ARCHIVING FINAL RESULTS ---\")\n","\n","    # 1. Write Anomalies Report (TSV)\n","    ANOMALY_HEADERS = [\"STATE_KEY\", \"S_START\", \"ANOMALY_STEP\", \"VAL_DEVIATION\", \"PATH_HISTORY\"]\n","    try:\n","        with open(\"anomalies_report.txt\", \"w\") as f:\n","            f.write(\"\\t\".join(ANOMALY_HEADERS) + \"\\n\")\n","            for anomaly in flagged_paths:\n","                # Truncate history for file output\n","                history_str = str(anomaly['path_history'])[:100] + '...'\n","                line = [\n","                    anomaly['key'],\n","                    str(anomaly['S_start']),\n","                    str(anomaly['total_steps']),\n","                    f\"{anomaly['val_deviation']:.4f}\",\n","                    history_str\n","                ]\n","                f.write(\"\\t\".join(line) + \"\\n\")\n","        print(\"✅ Anomalies Report (anomalies_report.txt) written successfully.\")\n","    except IOError as e:\n","        print(f\"❌ Error writing anomalies_report.txt: {e}\")\n","\n","\n","    # 2. Write Metadata Report (JSON)\n","    metadata = GMapService.get_interesting_metadata()\n","\n","    # Mock data insertion for final file\n","    final_metadata = {\n","        \"project_id\": \"Collatz-Symbolic-T-Tree-k3\",\n","        \"completion_date\": time.strftime(\"%Y-%m-%d\"),\n","        # Use mock completion data, but in production, this would be 10^11\n","        \"total_unique_states_processed\": GMapService.get_total_unique_states(),\n","        \"time_elapsed_seconds\": f\"{elapsed_time:.2f}\",\n","\n","        \"longest_path_found\": {\n","            \"metric\": \"Total Steps\",\n","            \"value\": metadata['longest_steps']['steps'],\n","            \"S_start\": metadata['longest_steps']['S_start'] or \"N/A\",\n","            \"key\": metadata['longest_steps']['key'] or \"N/A\"\n","        },\n","\n","        \"maximum_ascent_found\": {\n","            \"metric\": \"Max Cumulative Ascent in Val(S)\",\n","            \"value\": f\"{metadata['max_ascent_val']['ascent']:.4f}\",\n","            \"S_start\": metadata['max_ascent_val']['S_start'] or \"N/A\",\n","            \"key\": metadata['max_ascent_val']['key'] or \"N/A\"\n","        },\n","\n","        \"anomalies_flagged_count\": len(flagged_paths)\n","    }\n","\n","    try:\n","        with open(\"metadata_report.json\", \"w\") as f:\n","            json.dump(final_metadata, f, indent=2)\n","        print(\"✅ Metadata Report (metadata_report.json) written successfully.\")\n","    except IOError as e:\n","        print(f\"❌ Error writing metadata_report.json: {e}\")\n","\n","\n","# --- Main Search Loop (Layer 2: Execution) ---\n","\n","def t_tree_search_simulation(initial_states: List[STATE_TUPLE]):\n","    \"\"\"\n","    Simulates the Contraction-Prioritized Parallel Search.\n","    Pushes only unique states (Layer 1 check) onto a local priority queue.\n","    \"\"\"\n","    start_time = time.time()\n","\n","    # Priority Queue stores: (priority_value, state_tuple, total_steps, cum_delta_val, path_history)\n","    # Priority value is NEGATIVE VALUATION to prioritize lower valuation (higher contraction)\n","    search_queue: List[Tuple[float, STATE_TUPLE, int, float, List[STATE_TUPLE]]] = []\n","\n","    # 1. Initialization: Seed the queue with unique initial states\n","    print(f\"--- Starting T-Tree Search Simulation (Initial Queue: {len(initial_states)} states) ---\")\n","\n","    for S_start in initial_states:\n","        if GMapService.check_and_add_state(S_start): # Check Layer 1 synchronization\n","            m, d_len, P, r = S_start\n","            initial_val = calculate_valuation(m, d_len)\n","\n","            # Priority: Negative valuation (low is better), Total Steps: 0, Cumulative Delta Val: 0\n","            heapq.heappush(search_queue, (-initial_val, S_start, 0, 0.0, [S_start]))\n","\n","    total_processed = 0\n","\n","    # 2. Main Search Loop\n","    while search_queue:\n","        neg_val_priority, S_current, total_steps, cum_delta_val, path_history = heapq.heappop(search_queue)\n","\n","        total_processed += 1\n","        current_val = -neg_val_priority # Recalculate true valuation\n","\n","        # --- Check for Terminal State (Contraction to known cycle) ---\n","        if S_current[0] == 0 and S_current[1] == 0:\n","            # Path terminated successfully. Report results for metadata tracking.\n","            # Max Ascent is the max value of -neg_val_priority that occurred in path_history\n","            max_ascent = max(calculate_valuation(s[0], s[1]) for s in path_history) - current_val\n","            GMapService.report_path_results(\n","                GMapService.get_state_key(S_current),\n","                path_history[0],\n","                total_steps,\n","                max_ascent\n","            )\n","            continue # Path closed, continue to next item in queue\n","\n","        # --- Check for Anomalous Path (Layer 2: Dynamic Contraction Threshold) ---\n","        expected_contraction = total_steps * EXPECTED_DELTA_VAL_PER_STEP\n","        anomaly_threshold = expected_contraction * CONTRACTION_THRESHOLD_FACTOR\n","\n","        if cum_delta_val > anomaly_threshold and total_steps > 0:\n","            FLAGGED_ANOMALIES.append({\n","                'key': GMapService.get_state_key(S_current),\n","                'S_start': path_history[0],\n","                'total_steps': total_steps,\n","                'cum_delta_val': cum_delta_val,\n","                'val_deviation': cum_delta_val - anomaly_threshold,\n","                'path_history': path_history\n","            })\n","            # Even if flagged, we continue processing to prove the path terminates.\n","\n","        # --- Status Reporting ---\n","        if total_processed % 500 == 0:\n","            elapsed = time.time() - start_time\n","            print(f\"Processed: {total_processed} | Queue Size: {len(search_queue)} | Current Step: {total_steps} | Time: {elapsed:.2f}s\")\n","\n","\n","        # --- Generate Successors ---\n","        successors = compute_symbolic_transition(S_current, K)\n","\n","        for S_prime in successors:\n","            if GMapService.check_and_add_state(S_prime): # Layer 1 Check\n","                # New State: Calculate priority and push to queue\n","                m_prime, d_len_prime, P_prime, r_prime = S_prime\n","                val_prime = calculate_valuation(m_prime, d_len_prime)\n","\n","                # Calculate contraction for this step\n","                delta_val_step = val_prime - current_val\n","                new_cum_delta_val = cum_delta_val + delta_val_step\n","                new_total_steps = total_steps + 1\n","\n","                new_path_history = path_history + [S_prime]\n","\n","                # Push back with new priority (negative valuation)\n","                heapq.heappush(search_queue, (-val_prime, S_prime, new_total_steps, new_cum_delta_val, new_path_history))\n","\n","\n","    # 3. Finalization and Archiving\n","    elapsed_time = time.time() - start_time\n","    print(\"\\n--- Simulation Complete ---\")\n","    print(f\"Total Unique States Claimed Globally: {GMapService.get_total_unique_states()}\")\n","    print(f\"Total States Processed Locally: {total_processed}\")\n","    print(f\"Time Elapsed: {elapsed_time:.2f} seconds\")\n","    print(f\"Flagged Anomalous Paths: {len(FLAGGED_ANOMALIES)}\")\n","\n","    # Final archiving step\n","    archive_results(FLAGGED_ANOMALIES, elapsed_time)\n","\n","\n","# --- Test Setup ---\n","if __name__ == '__main__':\n","    # Initial states are derived from residues (r=1 to 99) and simplified P/m/d_len\n","    MOCK_INITIAL_STATES: List[STATE_TUPLE] = [\n","        (random.randint(1, 5), 10, random.randint(1, 100), r)\n","        for r in random.sample(range(1, 100), SIMULATION_STATES)\n","    ]\n","    t_tree_search_simulation(MOCK_INITIAL_STATES)\n"],"metadata":{"id":"VHHOUgTBATqF"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"provenance":[{"file_id":"1SssM0sj4rLAdYP1mijne6zCiihuT7QX6","timestamp":1760131517406}]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}