{"cells":[{"cell_type":"code","source":["import hashlib\n","import heapq\n","import random\n","import time\n","import math\n","import json\n","from typing import Tuple, Set, Optional, Dict, Any, List\n","\n","# --- Constants and Configuration ---\n","# State structure: (m, d_len, P, r)\n","STATE_TUPLE = Tuple[int, int, int, int]\n","K = 3  # The k value for the 2k+1 map (Collatz is k=1, but symbolic is k=3)\n","SIMULATION_STATES = 10  # Number of random initial states to test the architecture\n","\n","# --- Cluster Architecture Optimization Constants ---\n","MAX_PATH_HISTORY_LENGTH = 100 # Max states stored in path_history before truncating (Memory optimization)\n","MAX_PATH_COMPUTE_TIME_SECONDS = 5.0 # Hard limit to prevent a single complex path from stalling a core\n","BATCH_SIZE = 500 # Conceptual batch size for G-Map interactions (improves network efficiency)\n","\n","# --- Contraction Constants ---\n","CONTRACTION_THRESHOLD_FACTOR = 0.5 # Paths must contract by at least 50% of the expected rate to avoid a flag\n","EXPECTED_DELTA_VAL_PER_STEP = -1.73 # Expected average contraction per step\n","\n","# Global State Map (G-Map) Simulation: Stores processed state keys\n","GLOBAL_STATE_MAP: Set[str] = set()\n","FLAGGED_ANOMALIES: List[Dict[str, Any]] = []\n","\n","# Local cache for one cluster node: Avoids costly network lookups for recently seen keys\n","LOCAL_RECENT_CACHE: Set[str] = set()\n","\n","# --- Mock GMap Service Implementation (Layer 1: Synchronization & Metadata) ---\n","# NOTE: In production, this would be a distributed database service.\n","\n","class GMapService:\n","    \"\"\"\n","    Simulates the Global State Map service for cluster synchronization and\n","    capturing interesting path metadata. Implements local caching for speed.\n","    \"\"\"\n","\n","    _processed_keys: Set[str] = GLOBAL_STATE_MAP\n","\n","    _path_metadata: Dict[str, Any] = {\n","        'longest_steps': {'steps': 0, 'S_start': None, 'key': None},\n","        'max_ascent_val': {'ascent': 0.0, 'S_start': None, 'key': None},\n","        'reported_paths_count': 0\n","    }\n","\n","    @staticmethod\n","    def get_state_key(S: STATE_TUPLE) -> str:\n","        \"\"\"Generates the unique, fixed-length SHA-256 key.\"\"\"\n","        s_serialized = f\"{S[0]}_{S[1]}_{S[2]}_{S[3]}\"\n","        return hashlib.sha256(s_serialized.encode('utf-8')).hexdigest()\n","\n","    @classmethod\n","    def check_and_add_state(cls, S: STATE_TUPLE) -> bool:\n","        \"\"\"Atomic operation: Returns True if NEW, False if Duplicate. Uses local cache first.\"\"\"\n","        state_key = cls.get_state_key(S)\n","\n","        # 1. Check Local Cache (High-speed lookup)\n","        if state_key in LOCAL_RECENT_CACHE:\n","            return False\n","\n","        # 2. Check Global Map (Simulates network call)\n","        if state_key in cls._processed_keys:\n","            LOCAL_RECENT_CACHE.add(state_key) # Cache globally found keys locally\n","            return False\n","        else:\n","            # Atomic claim: Add to both global map (integrity) and local cache (speed)\n","            cls._processed_keys.add(state_key)\n","            LOCAL_RECENT_CACHE.add(state_key)\n","            return True\n","\n","    @classmethod\n","    def get_total_unique_states(cls) -> int:\n","        return len(cls._processed_keys)\n","\n","    @classmethod\n","    def report_path_results(cls, path_key: str, S_start: STATE_TUPLE,\n","                            total_steps: int, max_cumulative_ascent: float) -> None:\n","        \"\"\"Updates the globally tracked 'most interesting' results.\"\"\"\n","        cls._path_metadata['reported_paths_count'] += 1\n","\n","        if total_steps > cls._path_metadata['longest_steps']['steps']:\n","            cls._path_metadata['longest_steps'] = {\n","                'steps': total_steps,\n","                'S_start': S_start,\n","                'key': path_key\n","            }\n","\n","        if max_cumulative_ascent > cls._path_metadata['max_ascent_val']['ascent']:\n","            cls._path_metadata['max_ascent_val'] = {\n","                'ascent': max_cumulative_ascent,\n","                'S_start': S_start,\n","                'key': path_key\n","            }\n","\n","    @classmethod\n","    def get_interesting_metadata(cls) -> Dict[str, Any]:\n","        \"\"\"Retrieves the globally tracked interesting results.\"\"\"\n","        return cls._path_metadata\n","\n","# --- Core Symbolic Math Functions ---\n","\n","def compute_symbolic_transition(S: STATE_TUPLE, K: int = K) -> List[STATE_TUPLE]:\n","    \"\"\"\n","    MOCK: Simulates the deterministic transition function T(S).\n","    \"\"\"\n","    m, d_len, P, r = S\n","\n","    # Simulate the branching factor (max 40)\n","    branch_count = random.randint(1, 40)\n","    successors = []\n","\n","    for _ in range(branch_count):\n","        m_prime = random.randint(0, 10)\n","        d_len_prime = d_len + random.randint(-1, 2)\n","        P_prime = P + random.randint(10, 50)\n","        r_prime = random.randint(0, 99)\n","\n","        successors.append((m_prime, d_len_prime, P_prime, r_prime))\n","\n","    return successors\n","\n","def calculate_valuation(m: int, d_len: int) -> float:\n","    \"\"\"\n","    MOCK: Calculates the logarithmic valuation metric Val(S).\n","    \"\"\"\n","    return math.log10(m + 1) + math.log10(d_len + 1) * 2.0\n","\n","\n","# --- Archiving Function (Final Step) ---\n","\n","def archive_results(flagged_paths: List[Dict[str, Any]], elapsed_time: float) -> None:\n","    \"\"\"\n","    Writes the final search results and metadata to persistent files.\n","    \"\"\"\n","    print(\"\\n--- ARCHIVING FINAL RESULTS ---\")\n","\n","    # 1. Write Anomalies Report (TSV)\n","    ANOMALY_HEADERS = [\"STATE_KEY\", \"S_START\", \"ANOMALY_STEP\", \"VAL_DEVIATION\", \"PATH_HISTORY_SNIPPET\", \"NOTE\"]\n","    try:\n","        with open(\"anomalies_report.txt\", \"w\") as f:\n","            f.write(\"\\t\".join(ANOMALY_HEADERS) + \"\\n\")\n","            for anomaly in flagged_paths:\n","                # Truncate history for file output\n","                history_str = str(anomaly.get('path_history', ''))[:100] + '...'\n","                line = [\n","                    anomaly['key'],\n","                    str(anomaly['S_start']),\n","                    str(anomaly['total_steps']),\n","                    f\"{anomaly['val_deviation']:.4f}\",\n","                    history_str,\n","                    anomaly.get('note', 'Contraction-Stall')\n","                ]\n","                f.write(\"\\t\".join(line) + \"\\n\")\n","        print(\"✅ Anomalies Report (anomalies_report.txt) written successfully.\")\n","    except IOError as e:\n","        print(f\"❌ Error writing anomalies_report.txt: {e}\")\n","\n","\n","    # 2. Write Metadata Report (JSON)\n","    metadata = GMapService.get_interesting_metadata()\n","\n","    final_metadata = {\n","        \"project_id\": \"Collatz-Symbolic-T-Tree-k3\",\n","        \"completion_date\": time.strftime(\"%Y-%m-%d\"),\n","        \"total_unique_states_processed\": GMapService.get_total_unique_states(),\n","        \"time_elapsed_seconds\": f\"{elapsed_time:.2f}\",\n","\n","        \"longest_path_found\": {\n","            \"metric\": \"Total Steps\",\n","            \"value\": metadata['longest_steps']['steps'],\n","            \"S_start\": metadata['longest_steps']['S_start'] or \"N/A\",\n","            \"key\": metadata['longest_steps']['key'] or \"N/A\"\n","        },\n","\n","        \"maximum_ascent_found\": {\n","            \"metric\": \"Max Cumulative Ascent in Val(S)\",\n","            \"value\": f\"{metadata['max_ascent_val']['ascent']:.4f}\",\n","            \"S_start\": metadata['max_ascent_val']['S_start'] or \"N/A\",\n","            \"key\": metadata['max_ascent_val']['key'] or \"N/A\"\n","        },\n","\n","        \"anomalies_flagged_count\": len(flagged_paths)\n","    }\n","\n","    try:\n","        with open(\"metadata_report.json\", \"w\") as f:\n","            json.dump(final_metadata, f, indent=2)\n","        print(\"✅ Metadata Report (metadata_report.json) written successfully.\")\n","    except IOError as e:\n","        print(f\"❌ Error writing metadata_report.json: {e}\")\n","\n","\n","# --- Main Search Loop (Layer 2: Execution) ---\n","\n","def t_tree_search_simulation(initial_states: List[STATE_TUPLE]):\n","    \"\"\"\n","    Simulates the Contraction-Prioritized Parallel Search.\n","    Pushes only unique states (Layer 1 check) onto a local priority queue.\n","    \"\"\"\n","    start_time = time.time()\n","\n","    # Priority Queue stores: (priority_value, state_tuple, total_steps, cum_delta_val, path_history, start_timestamp)\n","    # The start_timestamp is used for the hard timeout check.\n","    search_queue: List[Tuple[float, STATE_TUPLE, int, float, List[STATE_TUPLE], float]] = []\n","\n","    # 1. Initialization: Seed the queue with unique initial states\n","    print(f\"--- Starting T-Tree Search Simulation (Initial Queue: {len(initial_states)} states) ---\")\n","\n","    for S_start in initial_states:\n","        if GMapService.check_and_add_state(S_start): # Check Layer 1 synchronization\n","            m, d_len, P, r = S_start\n","            initial_val = calculate_valuation(m, d_len)\n","\n","            # Priority: Negative valuation (low is better), Total Steps: 0, Cumulative Delta Val: 0\n","            # Start timestamp is current time\n","            heapq.heappush(search_queue, (-initial_val, S_start, 0, 0.0, [S_start], time.time()))\n","\n","    total_processed = 0\n","\n","    # 2. Main Search Loop\n","    while search_queue:\n","        neg_val_priority, S_current, total_steps, cum_delta_val, path_history, start_timestamp = heapq.heappop(search_queue)\n","\n","        total_processed += 1\n","        current_val = -neg_val_priority # Recalculate true valuation\n","\n","        # --- Check for Hard Time-Out (Mitigation for unexpected complexity) ---\n","        if time.time() - start_timestamp > MAX_PATH_COMPUTE_TIME_SECONDS:\n","            print(f\"⚠️ Hard Timeout! Path from {path_history[0]} exceeded {MAX_PATH_COMPUTE_TIME_SECONDS}s and was terminated.\")\n","            FLAGGED_ANOMALIES.append({\n","                'key': GMapService.get_state_key(S_current),\n","                'S_start': path_history[0],\n","                'total_steps': total_steps,\n","                'cum_delta_val': cum_delta_val,\n","                'val_deviation': 999.0, # High deviation to mark as critical failure\n","                'path_history': path_history,\n","                'note': 'TERMINATED_BY_TIMEOUT'\n","            })\n","            continue # Terminate this path and move to the next item in queue\n","\n","        # --- Check for Terminal State (Contraction to known cycle) ---\n","        if S_current[0] == 0 and S_current[1] == 0:\n","            # Path terminated successfully. Report results for metadata tracking.\n","            max_ascent = max(calculate_valuation(s[0], s[1]) for s in path_history if isinstance(s, tuple)) - current_val\n","            GMapService.report_path_results(\n","                GMapService.get_state_key(S_current),\n","                path_history[0],\n","                total_steps,\n","                max_ascent\n","            )\n","            continue # Path closed, continue to next item in queue\n","\n","        # --- Check for Anomalous Path (Layer 2: Dynamic Contraction Threshold) ---\n","        expected_contraction = total_steps * EXPECTED_DELTA_VAL_PER_STEP\n","        anomaly_threshold = expected_contraction * CONTRACTION_THRESHOLD_FACTOR\n","\n","        if cum_delta_val > anomaly_threshold and total_steps > 0:\n","            FLAGGED_ANOMALIES.append({\n","                'key': GMapService.get_state_key(S_current),\n","                'S_start': path_history[0],\n","                'total_steps': total_steps,\n","                'cum_delta_val': cum_delta_val,\n","                'val_deviation': cum_delta_val - anomaly_threshold,\n","                'path_history': path_history,\n","                'note': 'Contraction-Stall'\n","            })\n","            # Even if flagged, we continue processing to prove the path terminates.\n","\n","        # --- Status Reporting ---\n","        if total_processed % 500 == 0:\n","            elapsed = time.time() - start_time\n","            print(f\"Processed: {total_processed} | Queue Size: {len(search_queue)} | Current Step: {total_steps} | Time: {elapsed:.2f}s\")\n","\n","\n","        # --- Generate Successors ---\n","        successors = compute_symbolic_transition(S_current, K)\n","\n","        for S_prime in successors:\n","            if GMapService.check_and_add_state(S_prime): # Layer 1 Check (Local Cache -> G-Map)\n","                # New State: Calculate priority and push to queue\n","                m_prime, d_len_prime, P_prime, r_prime = S_prime\n","                val_prime = calculate_valuation(m_prime, d_len_prime)\n","\n","                # Calculate contraction for this step\n","                delta_val_step = val_prime - current_val\n","                new_cum_delta_val = cum_delta_val + delta_val_step\n","                new_total_steps = total_steps + 1\n","\n","                new_path_history = path_history + [S_prime]\n","\n","                # Path History Truncation (Memory Optimization)\n","                if len(new_path_history) > MAX_PATH_HISTORY_LENGTH:\n","                    new_path_history = [new_path_history[0]] + [\"...TRUNCATED...\"] + new_path_history[-MAX_PATH_HISTORY_LENGTH+2:]\n","\n","                # Push back with new priority (negative valuation) and original start timestamp\n","                heapq.heappush(search_queue, (-val_prime, S_prime, new_total_steps, new_cum_delta_val, new_path_history, start_timestamp))\n","\n","\n","    # 3. Finalization and Archiving\n","    elapsed_time = time.time() - start_time\n","    print(\"\\n--- Simulation Complete ---\")\n","    print(f\"Total Unique States Claimed Globally: {GMapService.get_total_unique_states()}\")\n","    print(f\"Total States Processed Locally: {total_processed}\")\n","    print(f\"Time Elapsed: {elapsed_time:.2f} seconds\")\n","    print(f\"Flagged Anomalous Paths: {len(FLAGGED_ANOMALIES)}\")\n","\n","    # Final archiving step\n","    archive_results(FLAGGED_ANOMALIES, elapsed_time)\n","\n","\n","# --- Test Setup ---\n","if __name__ == '__main__':\n","    # Initial states are derived from residues (r=1 to 99) and simplified P/m/d_len\n","    MOCK_INITIAL_STATES: List[STATE_TUPLE] = [\n","        (random.randint(1, 5), 10, random.randint(1, 100), r)\n","        for r in random.sample(range(1, 100), SIMULATION_STATES)\n","    ]\n","    t_tree_search_simulation(MOCK_INITIAL_STATES)"],"outputs":[],"execution_count":null,"metadata":{"id":"sg-1fAPkEGR9"}},{"cell_type":"code","source":["from google.colab import drive\n","drive.mount('/content/drive')"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"l3TJQphmEIxh","executionInfo":{"status":"ok","timestamp":1760132390992,"user_tz":240,"elapsed":19319,"user":{"displayName":"Adrienne Azurin-Cain","userId":"05729201531406487854"}},"outputId":"1c1e58bb-5e4e-4429-b011-bd46e80a9bb1"},"execution_count":1,"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}]}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}